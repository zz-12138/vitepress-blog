## JS随记

1. 严格模式下禁止js指向window。

2. js在解释执行之前，有预编译过程，会将变量申明提升到最前面。

3. 函数声明和变量声明都会被提升。但是一个值得注意的细节就是函数会首先被提升，然后才是变量。

3. js解析器在调用函数每次都会向函数内部传递一个隐含的参数，这个隐含的参数就是this，this指向的是一个对象，这个对象我们称之为函数执行的上下文对象。

3. 箭头函数this指向的会继承外层函数调用的this绑定。

3. js不会对函数传入的形参进行检测，所以可以不传值（参数为undefined），也可以传多个值。

4. 函数内部参数arguments可以将传入的所有参数以数组形式收集。

4. 全局变量会自动变成全局对象（比如浏览器中的window对象）的属性，因此可以不直接通过全局对象的词法名称（a），而是间接的通过全局对象属性的引用（window.a）来对其进行访问。

4. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

4. js引擎在解释代码之前首先对其进行编译，编译阶段中的部分工作就是找到所有的声明，并用适用的作用域将其关联起来。

4. js作用域只有函数作用域和全局作用域（es6中新增let，const的块级作用域），因为for循环结构不是函数，所以for中的变量会被提升到全局作用域；但es6中的块级作用域没有let，const没有变量提升。

5. 匿名函数和具名函数的区别：

   * ```js
     var fn  = function() {
         console.log('变量声明提升')
     }
     
     function fn() {
         console.log('函数的声明提升，会将整个函数提升到最前面')
     }
     ```

6. 函数的闭包：

   * ```js
     function A() {
         var a = 'zz'
         var b = 'aa'
         function B() {
             console.log(a+b)
         }
         return B
     }
     console.log(A()) //fnc B
     console.log(A()()) //console.log('zzaa')，变量a，b没有被销毁
     ```

3. js数据类型：
   * 基本数据类型：String、Number、Boolean、Null 空值、Undefined 未定义
   * 引用数据类型：Object
   * typeof 运算符：获取变量类型（typeof null 返回Object）
   * 任何数值与undefined运算都是NaN；任何数值与null运算，null都充当0
   * 当比较运算符两边都是字符串时，不会进行数值转换，比较的是字符串的字符编码
   
8. constructor（）构造器中this指向类的实例对象。

9. 类中所有定义的函数都再局部开启严格模式，若非类的实例对象调用，则this指向undefined（非window）。

10. 类中直接定义的属性会添加到构造器中。

11. 赋值语句+箭头函数，this指向类的实例对象。

6. 高阶函数：
   * 若A函数，接受的参数是一个函数，那么A可以称为高阶函数
   * 若A函数，调用的返回值依然是一个函数，那么A可以称为高阶函数
   
7. 函数柯里化：
   * 通过函数调用继续返回函数的方式，实现多次接受参数最后统一处理的函数编码形式	
   
14. 第一种情况，`super`作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次`super`函数。

11. 第二种情况，`super`作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

